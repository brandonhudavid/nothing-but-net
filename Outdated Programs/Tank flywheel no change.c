#pragma config(Motor,  port1,           DFR,           tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port2,           FW1,           tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port3,           FW2,           tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port4,           FW3,           tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port5,           FW4,           tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port6,           DBL,           tmotorVex393, openLoop)
#pragma config(Motor,  port7,           DBR,           tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port8,           conveyor,      tmotorVex393, openLoop)
#pragma config(Motor,  port9,           DMID,          tmotorVex393, openLoop)
#pragma config(Motor,  port10,          DFL,           tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Github test

/* Downloaded to Brain #4
09/11/2015: Motors 35 and 48 used for Flywheel
Lateral function will not work (middle motor cannot move entire robot).
Flywheel is front, intake is back.
Looking directly at the flywheel, ports 2 and 3 are left; ports 4 and 5 are right. */

void Flywheel(int speed)
{
	motor[FW1] = speed;
	motor[FW2] = speed;
	motor[FW3] = speed;
	motor[FW4] = speed;
}

void Straight(int speed)
{
	motor[DBL] = speed;
	motor[DFL] = speed;
	motor[DBR] = speed;
	motor[DFR] = speed;
}

void Lateral(int speed)
{
	motor[DMID] = speed;
}

void Rotate(int speed)
{
	motor[DBL] = speed;
	motor[DFL] = speed;
	motor[DBR] = -speed;
	motor[DFR] = -speed;
}

task main()
{
	// "power" will be used to manipulate the flywheel's power while it is spinning.
	// General threshold value.
	// Variable "x" used to gradually increase flywheel power in the first 0.35 seconds.
	// "flypower" is a manipulated value used to gradually reduce the flywheel's power when Button 5U is released.
	int power = 0;
	int threshold = 20;
	int x = 0;
	float flypower = 127.0;

	while(true)
	{
		// Buttons 7U and 7D will increase and decrease the flywheel's power.
		if(vexRT[Btn7U] == 1)
		{
			if(power >= 0)
			{
				power = 0;
			}
			else
			{
				power++;
			}
		}

		if(vexRT[Btn7D] == 1)
		{
			if(power <= -2)
			{
				power = -2;
			}
			else
			{
				power--;
			}
		}

		// Flywheel's power is affected by the value of "power", which is manipulated by buttons 7U and 7D.
		if((vexRT[Btn5U] == 1) && (motor[FW1] >= 70))
		{
			if(power == 0)
			{
				Flywheel(127);
			}
			else if(power == -1)
			{
				Flywheel(100);

			}
			else if(power == -2)
			{
				Flywheel(80);
			}
		}

		// When Button 5U is pressed, flywheel starts at 60 power for 2.5 seconds.
		else if(vexRT[Btn5U] == 1)
		{
			x = x+10;
			Flywheel(x);
			wait1Msec(50);
		}

		// When Button 5U is released, flywheel's power is divided by 1.2 every 0.5 seconds.
		else if(motor[FW1] >= 8)
		{
			flypower = flypower/1.2;
			Flywheel(flypower);
			wait1Msec(500);
		}
		else
		{
			Flywheel(0);
			flypower = 127.0;
			power = 0;
			x = 0;
		}

		// Slide drive: Arcade

		if(abs(vexRT[Ch3]) > threshold)
		{
			Straight(vexRT[Ch3]);
		}
		else if(abs(vexRT[Ch1]) > threshold)
		{
			Rotate(vexRT[Ch1]);
		}
		else
		{
			Straight(0);
		}

		// Conveyor intake
		if(vexRT[Btn6U] == 1)
		{
			motor[conveyor] = 75;
		}
		else if(vexRT[Btn6D] == 1)
		{
			motor[conveyor] = -75;
		}
		else
		{
			motor[conveyor] = 0;
		}

		/* Strafing, lateral movement w/ middle motor (seems to be too weak) */
		if(abs(vexRT[Ch4]) > threshold)
		{
			Lateral(vexRT[Ch4]);
		}
		else
		{
			Lateral(0);
		}
	}
}
